/// @file Carbon.h
/// 
/// Carbon generates c-linkable interfaces for constructs generated by Alchemy.
/// 
/// The MIT License(MIT)
/// 
/// @copyright 2014 Paul M Watt
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files(the "Software"), to deal
/// in the Software without restriction, including without limitation the rights
/// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
/// copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions :
/// 
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
/// THE SOFTWARE.
/// 
//  ***************************************************************************
#ifndef CARBON_H_INCLUDED
#define CARBON_H_INCLUDED
//  Includes ******************************************************************
#include <C/carbonate.h>


// TODO: May not be the final location.
// The definition that indicates these 
// functions will be publically accessible.
#if defined(_WIN32)

# if defined(ALCHEMY_EXPORT)
#   define ALCHEMY_API __declspec(dllexport)
# else
#   define ALCHEMY_API __declspec(dllimport)
# endif

#else

#define ALCHEMY_API

#endif



// Disable name-mangling for these 
// functions when compiled with C++.
#ifdef __cplusplus
extern "C"
{
#endif

//  ****************************************************************************
typedef unsigned char     Hg_msg_t;
typedef unsigned long     Hg_type_t;

//  ****************************************************************************
/// Reports the type of endianess of the local system.
///
/// @return     
///
ALCHEMY_API 
int Hg_local_endianess();

//  ****************************************************************************
/// Creates a new Hg message object of the specified type.
/// The caller must call Hg_destroy when they are done with the returned 
/// object to return the messages allocated memory.
///
/// @param msg_type[in] 
///
/// @return             On success, an allocated message pointer is returned.
///                       This pointer can be cast to the structure that 
///                       matches the type of requested message.
///                     0 is returned on failure.
///
ALCHEMY_API 
Hg_msg_t* Hg_create(
  Hg_type_t msg_type
);

//  ****************************************************************************
/// Creates a complete clone of an existing Hg message object.
/// The caller must call Hg_destroy when they are done with the returned 
/// object to return the messages allocated memory.
///
/// @param p_src[in]    A valid message object that should be cloned.
///                     All of the data inside of the message, including
///                     dynamically allocated space will be initialized to
///                     match the source message.
///
/// @return             On success, an allocated message pointer is returned.
///                       This pointer can be cast to the structure that 
///                       matches the type of requested message.
///                     0 is returned on failure.
///
ALCHEMY_API
Hg_msg_t* Hg_clone(
  const Hg_msg_t* p_src
);

//  ****************************************************************************
/// The specified message is destroyed.
/// ALL memory is reclaimed, including dynamically allocated space.
///
/// @param p_msg[in]    The previously allocated message to be destroyed.
///                     This message should not be used after it is passed 
///                     to this function.
///
ALCHEMY_API
void  Hg_destroy(
  Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Resize the buffer for a dynamically allocated field in an existing message.
///
/// @param p_msg[inout]
/// @param p_field[inout]
/// @param len[in]
///
/// return              The number of bytes allocated for the field is returned.
///                     If no bytes can be allocated, 0 is returned.
///
ALCHEMY_API 
size_t Hg_resize_dynamic(
  Hg_msg_t* p_msg, 
  void*     p_field, 
  size_t    len
);

//  ****************************************************************************
/// Returns the type of the specified message.
///
///
ALCHEMY_API 
Hg_type_t Hg_type(
  const Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Returns the size of the specified message.
///
///
ALCHEMY_API 
size_t Hg_size(
  const Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Returns the number of bytes that are required to serialize this object.
///
///
ALCHEMY_API 
size_t Hg_data_size(
  const Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Converts this object, in-place, to network byte-order.
/// No actions will be performed if the local platform is big-endian.
///
///
///
ALCHEMY_API 
int Hg_to_network(
  Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Converts this object, in-place, to host byte-order.
/// No actions will be performed if the local platform is big-endian.
///
///
///
ALCHEMY_API 
int Hg_to_host(
  Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Converts this object, in-place, to big-endian byte-order.
/// The message will always be converted as requested.
///
///
///
ALCHEMY_API 
int Hg_to_big_end(
  Hg_msg_t* p_msg
);

//  ****************************************************************************
/// Converts this object, in-place, to little-endian byte-order.
/// The message will always be converted as requested.
///
///
///
ALCHEMY_API 
int Hg_to_little_end(
  Hg_msg_t* p_msg
);
          
// TODO: I don't think this one will be useful, too many variables need to match properly. It would just be better to clone.
//  ****************************************************************************
/// Copies the contents of one existing message into another message.
///
///
ALCHEMY_API 
int Hg_copy(
  Hg_msg_t*       p_dest, 
  const Hg_msg_t* p_src
);
          
//  ****************************************************************************
/// Serializes the specified message into a buffer.
///
///
ALCHEMY_API 
size_t Hg_pack(
  const Hg_msg_t* p_msg, 
  void*           p_buffer, 
  size_t          len
);

//  ****************************************************************************
/// Deserializes the specified message from a buffer.
///
///
ALCHEMY_API 
size_t Hg_unpack(
  Hg_msg_t*   p_msg, 
  const void* p_buffer, 
  size_t      len
);


// End of name-mangling guard.
#ifdef __cplusplus
}
#endif

#endif
